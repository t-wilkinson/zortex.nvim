diff --git a/lua/zortex/open_link.lua b/lua/zortex/open_link.lua
index c26e6b8..a44d6d8 100644
--- a/lua/zortex/open_link.lua
+++ b/lua/zortex/open_link.lua
@@ -2,6 +2,83 @@ local extract_link = require("zortex.extract_link")
 
 local M = {}
 
+-- ---------------------------------------------------------------------------
+--  Helpers: pull @@Article title & @tags so the quick‑fix list is informative
+-- ---------------------------------------------------------------------------
+
+-- trivial whitespace trim (avoid relying on nightly vim.trim)
+local function _trim(s)
+	return (s:gsub("^%s*(.-)%s*$", "%1"))
+end
+
+---Return a concise path for quick‑fix display.
+---If the note lives under g:zortex_notes_dir we strip that prefix; otherwise we
+---fall back to a ~‑abbreviated / CWD‑relative variant.
+---@param file_path string
+---@return string
+local function shorten_path(file_path)
+	local notes_dir = vim.g.zortex_notes_dir and vim.fn.expand(vim.g.zortex_notes_dir) or nil
+	if notes_dir and file_path:sub(1, #notes_dir) == notes_dir then
+		local rel = file_path:sub(#notes_dir + 1)
+		if rel:sub(1, 1) == "/" then
+			rel = rel:sub(2)
+		end
+		return rel
+	end
+	return vim.fn.fnamemodify(file_path, ":~:.") -- "~/…" or ./… if inside cwd
+end
+
+---Read the first ~30 lines of an article and extract metadata
+---@param file_path string full path to note
+---@return string|nil title  -- the line starting with "@@" (without the prefix)
+---@return table tags        -- array of tag strings (without the leading "@")
+local function get_article_metadata(file_path)
+	local title = nil
+	local tags = {}
+	local f = io.open(file_path, "r")
+	if not f then
+		return title, tags
+	end
+
+	local i = 0
+	for line in f:lines() do
+		i = i + 1
+		if line:sub(1, 2) == "@@" then -- @@ArticleName
+			title = _trim(line:sub(3))
+		elseif line:sub(1, 1) == "@" and line:sub(2, 1) ~= "@" then -- single @tag
+			local tag = _trim(line:sub(2))
+			if tag ~= "" then
+				table.insert(tags, tag)
+			end
+		end
+		if i >= 30 then
+			break
+		end -- we only need the header block
+	end
+	f:close()
+	return title, tags
+end
+
+---Prefix a quick‑fix text with metadata ("Article | @tag1 @tag2 | …")
+---@param file_path string path for which to fetch metadata
+---@param base_text string existing qf description (match info)
+---@return string
+local function build_qf_text(file_path, base_text)
+	local title, tags = get_article_metadata(file_path)
+	local pieces = {}
+	if title and title ~= "" then
+		table.insert(pieces, title)
+	end
+	if #tags > 0 then
+		table.insert(pieces, "@" .. table.concat(tags, " @"))
+	end
+	if #pieces > 0 then
+		return table.concat(pieces, " | ") -- .. " | " .. base_text
+	else
+		return base_text
+	end
+end
+
 -- For Neovim 0.7+ path joining, otherwise use manual concatenation.
 local joinpath = vim.fs and vim.fs.joinpath
 	or function(...)
@@ -65,10 +142,14 @@ local function search_articles_by_tag(tag_to_find)
 					lnum = lnum + 1
 					if file_line:lower():find(lua_search_pattern) then
 						table.insert(qf_list, {
-							filename = full_path,
+							filename = shorten_path(full_path),
+							bufnr = vim.fn.bufadd(full_path),
 							lnum = lnum,
 							col = 1,
-							text = string.format("[@%s] %s", tag_to_find, file_line:gsub("[\r\n]", "")),
+							text = build_qf_text(
+								full_path,
+								string.format("[@%s] %s", tag_to_find, file_line:gsub("[\r\n]", ""))
+							),
 							valid = 1,
 						})
 						break -- Found tag, move to next file
@@ -147,10 +228,14 @@ local function search_articles_by_tag_and_header(tag_to_find, header_to_find)
 
 				if has_tag and header_match then
 					table.insert(qf_list, {
-						filename = full_path,
+						filename = shorten_path(full_path),
+						bufnr = vim.fn.bufadd(full_path),
 						lnum = header_match.lnum,
 						col = header_match.col,
-						text = string.format("[@%s/#%s] %s", tag_to_find, header_to_find, header_match.text),
+						text = build_qf_text(
+							full_path,
+							string.format("[@%s/#%s] %s", tag_to_find, header_to_find, header_match.text)
+						),
 						valid = 1,
 					})
 				end
@@ -232,10 +317,11 @@ local function find_article_file_by_name_and_tag(article_name, tag_to_find)
 
 				if has_article_name and has_tag then
 					table.insert(qf_list, {
-						filename = full_path,
+						filename = shorten_path(full_path),
+						bufnr = vim.fn.bufadd(full_path),
 						lnum = article_lnum,
 						col = 1,
-						text = string.format("[%s/@%s]", article_name, tag_to_find),
+						text = build_qf_text(full_path, string.format("[%s/@%s]", article_name, tag_to_find)),
 						valid = 1,
 					})
 				end
@@ -470,10 +556,14 @@ function M.search_all_articles_globally(target_type, target_text)
 			local s, e = line_to_search:find(pattern)
 			if s then
 				table.insert(qf_list, {
-					filename = file_path,
+					filename = shorten_path(file_path),
+					bufnr = vim.fn.bufadd(file_path),
 					lnum = lnum,
 					col = s,
-					text = string.format("[%s: %s] %s", description, target_text, file_line:gsub("[\r\n]", "")), -- Ensure text is single line for qf
+					text = build_qf_text(
+						file_path,
+						string.format("[%s: %s] %s", description, target_text, file_line:gsub("[\r\n]", ""))
+					),
 					valid = 1,
 				})
 			end
